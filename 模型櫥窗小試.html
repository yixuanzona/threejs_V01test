<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>模型小櫥窗</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f1012; /* 深色背景襯托玻璃質感 */
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .info-text {
            position: absolute; top: 40px; left: 40px; 
            color: rgba(255, 255, 255, 0.8); z-index: 10; 
            pointer-events: none;
        }
        h1 { font-weight: 300; margin: 0; letter-spacing: 4px; font-size: 1.5rem; text-transform: uppercase; }
        .subtitle { font-size: 0.9rem; margin-top: 5px; opacity: 0.6; }
        
        #loading-text {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2rem; z-index: 100; pointer-events: none;
            transition: opacity 0.5s;
        }
        /* UI 滑桿樣式調整 */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 75%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

    <div id="loading-text">載入模型中... 0%</div>

    <div class="info-text">
        <h1>Custom Model Showcase</h1>
        <div class="subtitle">RABBIT</div>
        <div class="mt-4 text-sm text-white-400 max-w-xs">
            目前展示：RABBIT<br>
            試著移動滑鼠，模型會平滑地跟隨你的游標轉動。
        </div>
    </div>
    
    <div id="control-panel" class="absolute top-4 right-4 z-10 p-4 rounded-lg bg-white/20 backdrop-blur-sm shadow-xl space-y-3 w-64 text-sm text-white/90">
        <div class="flex flex-col space-y-2">
            <label for="exposureSlider" class="font-bold">環境亮度 (Exposure):</label>
            <div class="flex items-center space-x-2">
                <input type="range" id="exposureSlider" min="0.5" max="5.0" step="0.1" value="1.0" class="w-full h-1 bg-white/50 rounded-lg appearance-none cursor-pointer">
                <span id="exposureValue" class="font-mono text-xs w-8 text-right">1.0</span>
            </div>
        </div>
        
        <div class="flex items-center justify-between pt-2">
            <label for="hdriToggle" class="font-bold">HDRI 背景圖</label>
            <input type="checkbox" id="hdriToggle" checked class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500">
        </div>
    </div>
    
    <button id="resetViewButton" class="absolute bottom-5 left-1/2 transform -translate-x-1/2 z-10 py-2 px-4 rounded-full bg-white/20 backdrop-blur-sm shadow-xl text-white/90 hover:bg-white/30 transition duration-150">
        回到正面視角
    </button>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        // --- 全域變數 ---
        let scene, camera, renderer, controls;
        let glassCube;
        let myModelGroup = new THREE.Group();
        let mouse = new THREE.Vector2();
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        let hdrTexture = null; // 【新增】儲存 HDRI 貼圖
        

        // --- 初始化 ---
        function init() {
            const container = document.getElementById('canvas-container');

            // 1. 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); 
            scene.fog = new THREE.FogExp2(0x111111, 0.02);

            // 2. 相機
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.5, 9);

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; // 【調整】曝光度預設 3.0，確保亮度足夠
            container.appendChild(renderer.domElement);

            // 4. 控制器 (限制視角，模擬櫥窗前觀看)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minPolarAngle = Math.PI / 3;
            controls.maxPolarAngle = Math.PI / 1.8;
            controls.minAzimuthAngle = -Math.PI / 4;
            controls.maxAzimuthAngle = Math.PI / 4;
            controls.enablePan = false;
            controls.enableZoom = false; 

            // 5. 環境貼圖 (HDRI)
            setupEnvironment(); 

            // 6. 燈光
            setupLighting();

            // 7. 建立玻璃櫥窗
            createGlassCube();

            // 8. 載入自訂模型
            loadCustomModel('./rabbit.glb');

            // 9. 事件監聽
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onDocumentMouseMove);
            
            // 【新增】UI 事件監聽
            document.getElementById('hdriToggle').addEventListener('change', toggleHdriBackground);
            document.getElementById('exposureSlider').addEventListener('input', updateExposure);
            document.getElementById('resetViewButton').addEventListener('click', resetCameraView);

            // 10. 啟動迴圈
            animate();
        }

        // --- 環境貼圖 (HDRI) 設置 ---
        function setupEnvironment() {
            new RGBELoader()
                .setPath('./assets/hdri/')
                .load('brown_photostudio_06_1k.hdr', function (texture) { 
                    
                    hdrTexture = texture; // 儲存貼圖到全域變數
                    
                    texture.mapping = THREE.EquirectangularReflectionMapping;

                    // 1. 設定為場景環境光 (PBR 質感提升關鍵，不受背景切換影響)
                    scene.environment = hdrTexture;

                    // 2. 初始時設定為場景背景 (因為 Checkbox 預設 checked)
                    scene.background = hdrTexture;
                
                });
        }
        
        // --- 專業燈光設置 (Ambient Light 調整為 0.5) ---
        function setupLighting() {
            RectAreaLightUniformsLib.init();

            // 【調整】提高輔助環境光強度至 0.5
            const ambientLight = new THREE.AmbientLight(0xffeedd, 0.5); 
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffeedd, 5);
            spotLight.position.set(0, 10, 0);
            spotLight.angle = Math.PI / 6;
            spotLight.penumbra = 1;
            spotLight.decay = 2;
            spotLight.distance = 50;
            spotLight.castShadow = true;
            scene.add(spotLight);

            const rectLight1 = new THREE.RectAreaLight(0x99ddff, 2, 2, 10);
            rectLight1.position.set(-5, 0, 0);
            rectLight1.lookAt(0, 0, 0);
            scene.add(rectLight1);

            const rectLight2 = new THREE.RectAreaLight(0xffccaa, 2, 2, 10);
            rectLight2.position.set(5, 0, 0);
            rectLight2.lookAt(0, 0, 0);
            scene.add(rectLight2);
            
            const bottomLight = new THREE.PointLight(0xffffff, 1, 10);
            bottomLight.position.set(0, -3, 2);
            scene.add(bottomLight);
        }

        // --- 建立高質感玻璃櫥窗 ---
        function createGlassCube() {
            const geometry = new THREE.BoxGeometry(3.5, 3.5, 3.5);

            // 霧面玻璃材質 (側面、頂部、底部、背面)
            const frostedGlass = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.4,
                transmission: 0.5,
                thickness: 1.5,
                side: THREE.BackSide, 
                clearcoat: 0.2,
                clearcoatRoughness: 0.3
            });

            // 清透玻璃材質 (正面)
            const clearGlass = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.05,
                transmission: 0.98,
                thickness: 0.5,
                transparent: true,
                opacity: 1,
                side: THREE.FrontSide,
                clearcoat: 1.0,
                ior: 1.5,
            });

            // 材質陣列: +x, -x, +y, -y, +z (Front), -z (Back)
            const materials = [
                frostedGlass, // Right (+x)
                frostedGlass, // Left (-x)
                frostedGlass, // Top (+y)
                frostedGlass, // Bottom (-y)
                clearGlass,   // Front (+z) 【確認：此為清澈玻璃】
                frostedGlass  // Back (-z)
            ];

            glassCube = new THREE.Mesh(geometry, materials);
            scene.add(glassCube);

            // 添加玻璃邊框
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            glassCube.add(wireframe);

            // 添加底部底座
            const baseGeo = new THREE.BoxGeometry(3.6, 0.2, 3.6);
            // 白金色材質設定
            const baseMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFE5B4, // 淺米白金色
                roughness: 0.1,  // 高光澤
                metalness: 1.0   // 確保是金屬質感
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = -1.85;
            scene.add(base);
        }

        // --- 核心：載入 GLTF/GLB 模型 ---
        function loadCustomModel(url) {
            const loader = new GLTFLoader();
            const loadingText = document.getElementById('loading-text');

            loader.load(
                url,
                function (gltf) {
                    const model = gltf.scene;
                    model.scale.set(1.5, 1.5, 1.5); 
                    model.position.set(0, 0, 0);

                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    myModelGroup.add(model);
                    scene.add(myModelGroup);

                    loadingText.style.opacity = 0; 
                    loadingText.style.fontSize = '0.5rem';
                    setTimeout(() => loadingText.remove(), 500);

                },
                function (xhr) {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0) + '%';
                    loadingText.innerText = '模型載入中... ' + percent;
                },
                function (error) {
                    console.error('載入失敗:', error);
                    loadingText.innerText = '載入失敗，請檢查網址或檔案 (詳見 Console 錯誤)';
                }
            );
        }

        // --- 【新增】HDRI 背景切換功能 ---
        function toggleHdriBackground(event) {
            // 只切換背景圖，環境光 (scene.environment) 保持不變
            if (event.target.checked && hdrTexture) {
                scene.background = hdrTexture;
            } else {
                // 關閉時使用深色純色背景
                scene.background = new THREE.Color(0x111111);
            }
        }

        // --- 【新增】曝光度調整功能 ---
        function updateExposure(event) {
            const exposure = parseFloat(event.target.value);
            renderer.toneMappingExposure = exposure;
            // 更新 UI 顯示的數值
            document.getElementById('exposureValue').innerText = exposure.toFixed(1);
        }

        // --- 【新增】回到正面視角功能 ---
        function resetCameraView() {
            // 1. 相機位置：回到初始位置 (0, 1.5, 9)
            camera.position.set(0, 1.5, 9); 
            
            // 2. 模型旋轉：回到 (0, 0, 0)
            myModelGroup.rotation.x = 0;
            myModelGroup.rotation.y = 0;
            
            // 3. OrbitControls 視角重設
            controls.reset();
            
            // 4. 重設滑鼠影響
            mouse.set(0, 0); 
        }

        // --- 事件處理 ---
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            mouse.x = (event.clientX - windowHalfX) / 100;
            mouse.y = (event.clientY - windowHalfY) / 100;
        }

        // --- 動畫迴圈 ---
        function animate() {
            requestAnimationFrame(animate);

            // --- 互動邏輯：讓模型平滑跟著滑鼠轉動 ---
            if (myModelGroup && myModelGroup.children.length > 0) {
                const targetRotationX = mouse.y * 0.05; 
                const targetRotationY = mouse.x * 0.05;
                
                const damping = 0.1; 
                myModelGroup.rotation.x += (targetRotationX - myModelGroup.rotation.x) * damping;
                myModelGroup.rotation.y += (targetRotationY - myModelGroup.rotation.y) * damping;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>